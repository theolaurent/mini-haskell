\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{listings}
\usepackage{examplep}

\title{TODO}

\author{Jun \textsc{Maillard} et Théo \textsc{Laurent}}

\begin{document}

\maketitle

\section{Interface du compilateur}

\subsection{Arguments}
En plus des options \verb$--parse-only$ et \verb$--type-only$, les options suivantes sont disponibles :
\begin{itemize}
\item[\PVerb{--print-ast}] Affiche l'arbre de syntaxe abstraite parsé.
\item[\PVerb{--print-type}] Affiche le type de chacune des variables globales.
\end{itemize}

\subsection{Report d'erreur}
Lors de chaque phase de la compilation (en l'occurence l'analyse syntaxique et le typage), le compilateur tente de trouver le plus d'erreurs possibles. Si à la fin d'une phase des erreurs ont été trouvées, elles sont affichées (dans l'ordre d'occurence) et la compilation s'arrête avec le code d'erreur $1$.

\subsection{Erreur de typage}
Lorsqu'une unification échoue, le terme de l'ast en cours d'inférence puis la trace des unifications successives sont affichées.

\section{Choix techniques}
\subsection{Analyse syntaxique}
Le lexeur et le parseur sont générés à l'aide des outils ocamllex et menhir, respectivement. \\
L'arbre syntaxique produit est un type riche : on distingue notamment les opérations binaires primitives (arithmétiques, logique, de comparaison et cons) des autre variables. Par contre les primitives \verb$div$, \verb$rem$, \verb$putChar$ et \verb$error$ sont traités comme n'importequ'elle variable.

\subsection{Typage}
Pour le typage, un système de type "à la MLF" a été implémenté (cf. section "Extension : MLF").

\subsection{Génération de code}
Pour la génération du code le compilateur passe par une représentation intermédiaire (IR). \\
Cette représentation est une suite d'instruction linéaire. Le résultat de chaque instruction de l'IR est supposé être passé implicitement à l'instruction suivante. \\
Elle peut accéder à la pile via les instructions \verb$Push$ et \verb$Pop$ ets certaines instructions modifient implicitement l'état de la pile (\verb$ApplyUncons$ ajoute deux élément à la pile ; \verb$ApplyUnnop$, \verb$ApplyBinop$ et \verb$CallFun$ enlèvent des élements de la pile (leur argument) ; \verb$StartFun$ et \verb$Return$ initialise et restaure le tableau d'activation lors d'un appel). \\
Lors de la transformation de l'ast vers cette IR, les noms de
variables sont remplaçés par leur emplacement (locale, argument, dans
l'environement la fermeture, globale).

C'est également a ce moment là que la construction des fermetures est
explicité, ainsi que la congélation et l'évaluation forcée. Sont
congelées les arguments des fonctions avant application et les valeurs
liées par un let. Sont forcés : les arguments des primitives
artihmétiques, logiques, etc... ; les arguments des primitives
\PVerb{div}, \PVerb{rem}, \PVerb{putChar} et \PVerb{error} lors de
l'application du dernier argument ; les conditions des instructions if
et enfin l'expression filtrée par \PVerb{case ... of}
\section{Difficultés rencontrées}

\section{Extension : MLF}


\end{document}
